/*
*********************************************************************************
*                                 STM32F103C8T6
*                     基于RVMDK集成开发环境,FreeRTOS应用库
*									 Ver1.1
*                                   皇家科技
*
*模  块：IC卡管理
*设计者：Andy
*时  间：2010-11-02

说明:
	通过展会，以及客户反馈的问题，对系统整体做了调整，玩家的媒介采用CPU卡，这样
	解决了脱机使用的问题，同时在无线的情况下，保证数据的稳定性，这样在无线不成熟
	的情况下，系统整体是稳定的
	2011-10-04

	根据项目进度，重新调整了该函数，采用M1卡作为会员卡媒介，对数据通过唯一的序列号
	进行DES加密，保证数据的安全性，数据作为备份使用
*********************************************************************************
*/
#include".\Lib\includes.h"

S_IC CtrIC;
S_FLAG FLAG;
S_STEP ST;
S_TIME TM;
S_CLOCK CLOCK;  
S_CLOCK CLOCK1;
S_CLOCK CLOCKSET;

S_ACCEPT ACCEPT;

INT8U CanMsgBeg=0;			//处理一个包，CanMsgBeg++
INT8U CanMsgEnd=0;			//写入一个包，CanMsgEnd++
CanRxMsg CanMsg[CAN_RxSize];//CAN数据包接收缓冲区

INT8U CanTxMsgBeg=0;			//处理一个包，CanMsgBeg++
INT8U CanTxMsgEnd=0;			//写入一个包，CanMsgEnd++
CanTxMsg CanTXMsg[CAN_RxSize];//CAN数据包接收缓冲区

xSemaphoreHandle xAskServerSemaphore;      /*!服务器应答的信号量*/

INT8U Deskey[16]={
	0xa6,0xb8,0xc8,0xd7,0xe4,0xf2,0x9d,0x78,
	0x6a,0x8b,0x8c,0x7d,0x4e,0x2f,0xd9,0x87,
};
INT8U KEY4[16]={
	//0xbf,0xda,0xe2,0xf2,0xf3,0x91,0xbd,0x96,      //!88888
	//0x8f,0xA9,0x9b,0x98,0x6b,0x4c,0xed,0x9b,
	
	//0xc0,0xdb,0xe4,0xf5,0xf4,0x92,0xbe,0x98,
	//0x90,0xAa,0x9d,0x9a,0x6c,0x4d,0xef,0x9c,   //!20001
	
	//0xc1,0xdc,0xe5,0xf7,0xf8,0xa2,0xce,0xa8,
	//0x91,0xAb,0xad,0xaa,0x7c,0x5d,0xff,0xac,     //!20002
	
	//0xc4,0xeb,0xf4,0xf6,0xf5,0x96,0xbf,0x9a,
	//0xa0,0xba,0xad,0xaa,0x6d,0x4e,0xe0,0x9d,     //!20003
	
	//0xc5,0xec,0xf5,0xf7,0xf6,0x97,0xb0,0x9b,
	//0xb0,0xca,0xbd,0xba,0x7d,0x5e,0xf0,0xad,       //!20005
	
	//0xc6,0xed,0xf6,0xf8,0xf7,0x98,0xb2,0x9d,     
	//0xb2,0xba,0xad,0xca,0x6d,0x6e,0x10,0xbd,      //!20006

	//0xc7,0xee,0xf7,0xf9,0xf9,0x99,0xb5,0x9d,
	//0xb2,0xba,0xad,0xaa,0x5d,0x3e,0x20,0x9d,         //!20007

	//0xc8,0xe2,0xfa,0xfb,0xf3,0xa9,0xa5,0xad,          //!20008
	//0xb4,0xbb,0xae,0xad,0x5e,0x4e,0x24,0x9e,


	//0xaf,0xc1,0xd1,0xe0,0xed,0xfb,0xa6,0x81,           //122
	//0x7c,0x94,0x95,0x86,0x57,0x38,0xe2,0x90,

		// 0xc2,0xdb,0xe4,0xf4,0xf4,0x92,0xbe,0x98,       //189
	    // 0x90,0xaa,0x9d,0x9a,0x6d,0x4e,0xed,0x9c,

		//0xb4,0x65,0xe4,0x31,0x56,0xc3,0xe8,0x0c,	    //237
		//0x84,0xa3,0xb4,0xac,0x23,0x55,0xd4,0xca,

	    //0xc4,0x65,0xe4,0x31,0x16,0xc3,0xe8,0x0c,    //239
	  	//0x83,0xa3,0xb4,0xdc,0x23,0x75,0xd4,0xba,
			
			//0xd4,0x65,0xe4,0x31,0x19,0xc3,0xe8,0x0c,
			//0x83,0xa3,0xb4,0xdc,0x23,0x75,0xd4,0xab,     //251
			
			//0xb4,0x65,0xe4,0x61,0x19,0xc3,0xb8,0x0c,  //252
			//0x45,0xa3,0xb4,0xdc,0x23,0x75,0xd4,0xcc,
			
			//0xd2,0xb6,0xe4,0xd1,0x46,0xd3,0xd8,0x0c,   //255
			//0x75,0xac,0xb4,0xec,0x23,0x25,0xf4,0xbb,
			
			//0xd3,0xb7,0xe6,0xc1,0x66,0xe3,0xe8,0x2c,   //256
			//0x85,0xbc,0xd4,0xfc,0x63,0x65,0x24,0xb6,

			//0xd4,0xb8,0xe7,0xc3,0x86,0xd3,0x68,0x3c,  //257
			//0xa5,0x3c,0xc4,0x3c,0x83,0x45,0x34,0x96,
			//0xd5,0xb9,0xe8,0xc4,0x87,0xd4,0x78,0x4c,    //!259
			//0xb5,0x4c,0xc6,0x3d,0x85,0x46,0x36,0x9a,
			//0xd6,0xba,0xe9,0xc5,0x85,0xd2,0x76,0x6c,  //260
			//0xc5,0x6c,0xd6,0x4d,0xa5,0x56,0x66,0x8a,
			//0xd7,0xbb,0xea,0xc6,0x89,0xd6,0x7a,0x4d,  //261
			//0xb8,0x4d,0xd6,0xdd,0xa5,0x66,0x66,0xaa,
			//0xd9,0xbc,0xeb,0xc8,0x8a,0xd8,0x9a,0x5d,  //262
			//0xc8,0x6d,0xe6,0xcd,0x65,0x68,0x96,0xae,

			//0xa9,0xbb,0xcb,0xda,0xe7,0xf5,0xa0,0x7b,  //115
			//0x6d,0x8e,0x8f,0x80,0x51,0x32,0xdc,0x8a,
			//0xda,0xbd,0xec,0xc9,0x8b,0xe8,0xaa,0x6d,  //263
			//0xd8,0x7d,0xf6,0xed,0xa5,0xa8,0xa6,0xfe,

		//0xdb,0xbe,0xed,0xca,0x8c,0xe9,0xab,0x7d,  //265
		//0xe8,0x8d,0xa6,0xad,0xb5,0xb8,0xc6,0xf8,

		//0xeb,0xce,0xfd,0xda,0xac,0xa9,0xdb,0x9d,    //266
		//0xf8,0xad,0xb6,0xcd,0xc5,0xc8,0xe6,0xe8,
		//0xc4,0x65,0xe4,0x51,0x56,0xc3,0xe6,0x0c, //229
		//0x84,0xbf,0xb4,0xac,0x23,0x55,0xe4,0xba,
		//0xef,0xc2,0xf1,0xde,0xa0,0xad,0xdf,0x91,//270
		//0x38,0xed,0xf6,0x0d,0xf5,0xe8,0x26,0x38,
		//0xe2,0xc5,0xf4,0xd1,0xa3,0xa0,0xd2,0x94, //273
		//0x68,0x1d,0x26,0x3d,0x25,0x18,0x56,0x68,
		//0xe3,0xc6,0xf5,0xd2,0xa4,0xa1,0xd3,0x95,//275
		//0x78,0x2d,0x36,0x4d,0x35,0x28,0x66,0x78,
		//0xe5,0xc8,0xf7,0xd4,0xa7,0xa4,0xd5,0x97,//280
		//0x98,0x4d,0x56,0x6d,0x55,0x48,0x86,0x98,
		//0xe5,0xc8,0xf7,0xd4,0xa6,0xa3,0xd5,0x97,//282
		//0x99,0x4c,0x56,0x6d,0x55,0x48,0x86,0x98,
		//0xe0,0xc2,0x04,0xe6,0xa8,0xaa,0xdb,0x9c,//96001
		//0x9d,0x1d,0x36,0x5d,0x75,0x98,0x86,0x98,
		0xe2,0xc4,0x06,0xe8,0xaa,0xac,0xdd,0xac,//96002
		0xad,0x2d,0x46,0x6d,0x85,0x9a,0x88,0x9a,
	};

INT8U gHJM1CardKey[6]={
  //0x3b, 0xda, 0xa3, 0x5d, 0xff, 0xCc,        //!88888
  //0x3c,0xdc,0xa4,0x5e,0x01,0xce,               //!20001
  //0x4c,0xec,0xa5,0x6e,0x11,0xde,          //!20002
  //0x3e,0xd5,0xa8,0x5c,0x04,0xcf,          //!20003
  //0x3f,0xd6,0xaa,0x6c,0x24,0xdf,            //!20005
  //0x32,0xd8,0xab,0x6d,0x34,0xef,             //!20006
  //0x1f,0xc8,0x9b,0x4e,0x45,0xcd,             //!20007
  //0x24,0xca,0x9c,0x5e,0x56,0xda,               //!20008
  //0x2d, 0xc7, 0x91, 0x49, 0xf0, 0xb6,             //122
  //  0x3c, 0xdb, 0xa5, 0x5c, 0x01, 0xce,         //189   
	 // 0xbb, 0xf1, 0x65, 0x23, 0xde, 0xd6,			 //237
	   // 0xbc, 0xf1, 0xc5, 0x23, 0xde, 0xd8,	 //239
	      //0xbd, 0xf1, 0xc5, 0x23, 0xde, 0xe2,   //251
	       //0xac, 0xf1, 0xd5, 0x23, 0xde, 0xf5,    //252
	       //  0x23, 0xb6, 0xa5, 0x23, 0xde, 0xe3,    //255
	//0x28, 0xb7, 0xa9, 0x53, 0xce, 0xd3, //256
	//0x2a, 0xd7, 0xaa, 0x55, 0xbe, 0xd8,  //257
	//0x2b, 0xe7, 0xca, 0x56, 0xba, 0xde,//259
  //0x2c, 0xe8, 0xcc, 0x76, 0xda, 0xd8, //260
  //0x2d, 0xe9, 0xcd, 0x86, 0xca, 0xee,//261
  //0x4d, 0xf9, 0xc2, 0x8a, 0xea, 0x6e,//262
  //0x26, 0xc0, 0x8a, 0x42, 0xe9, 0xaf,//115
  //0x4e, 0xfa, 0xd2, 0xaa, 0xfa, 0x9e, //263
  // 0x2d, 0xc7, 0x91, 0x49, 0xf0, 0xb6,  //122
  //0x6e, 0xfc, 0xd3, 0xac, 0xfb, 0xae, //265
  //0x8e, 0xfd, 0xd6, 0xbc, 0xdb, 0xbe, //266
  //0x5b, 0xf7, 0xa5, 0x23, 0xde, 0xc6,//90229
	//0xce, 0x3d, 0x07, 0xb0, 0xdf, 0xb2,//270
	//0xfe, 0x6d, 0x37, 0xb3, 0xd2, 0xb5,//273
	//0x0e, 0x7d, 0x47, 0xb4, 0xd3, 0xb6,//275
	//0x5e, 0x1d, 0xc7, 0xb7, 0xd8, 0xb0,//280
	//0x7e, 0xfd, 0x17, 0xb3, 0xda, 0xb2,//282
	//0x1e, 0x2d, 0x37, 0xb4, 0xd6, 0xb8,//96001
	0x2e, 0x3d, 0x47, 0xc4, 0xd7, 0xba,//96002
};

INT8U  KEYDES[16]=
	{
		//0xbf,0xda,0xe2,0xf2,0xf3,0x91,0xbd,0x96,  
		//0x8f,0xA9,0x9b,0x98,0x6b,0x4c,0xed,0x9b, //182
		
		//0xc0,0xdb,0xe4,0xf5,0xf4,0x92,0xbe,0x98,
		//0x90,0xAa,0x9d,0x9a,0x6c,0x4d,0xef,0x9c,   //!20001
		
		//0xc1,0xdc,0xe5,0xf7,0xf8,0xa2,0xce,0xa8,
		//0x91,0xAb,0xad,0xaa,0x7c,0x5d,0xff,0xac,     //!20002
		
		//0xc4,0xeb,0xf4,0xf6,0xf5,0x96,0xbf,0x9a,
		//0xa0,0xba,0xad,0xaa,0x6d,0x4e,0xe0,0x9d,     //!20003
		
		//0xc5,0xec,0xf5,0xf7,0xf6,0x97,0xb0,0x9b,
		//0xb0,0xca,0xbd,0xba,0x7d,0x5e,0xf0,0xad,       //!20005
		
		//0xc6,0xed,0xf6,0xf8,0xf7,0x98,0xb2,0x9d,     
		//0xb2,0xba,0xad,0xca,0x6d,0x6e,0x10,0xbd,      //!20006
		
		//0xc7,0xee,0xf7,0xf9,0xf9,0x99,0xb5,0x9d,
		//0xb2,0xba,0xad,0xaa,0x5d,0x3e,0x20,0x9d,         //!20007

		//0xc8,0xe2,0xfa,0xfb,0xf3,0xa9,0xa5,0xad,        //!20008
		//0xb4,0xbb,0xae,0xad,0x5e,0x4e,0x24,0x9e,

		//0xaf,0xc1,0xd1,0xe0,0xed,0xfb,0xa6,0x81,          //122
		//0x7c,0x94,0x95,0x86,0x57,0x38,0xe2,0x90,

	   //0xc2,0xdb,0xe4,0xf4,0xf4,0x92,0xbe,0x98,       //189
	 	//0x90,0xaa,0x9d,0x9a,0x6d,0x4e,0xed,0x9c,


     //0xb4,0x65,0xe4,0x31,0x56,0xc3,0xe8,0x0c,	    //237
     //	0x84,0xa3,0xb4,0xac,0x23,0x55,0xd4,0xca,

		//0xc4,0x65,0xe4,0x31,0x16,0xc3,0xe8,0x0c,    //239
		//0x83,0xa3,0xb4,0xdc,0x23,0x75,0xd4,0xba,
		
		  //0xd4,0x65,0xe4,0x31,0x19,0xc3,0xe8,0x0c,
			//0x83,0xa3,0xb4,0xdc,0x23,0x75,0xd4,0xab,     //251
   
	    //0xb4,0x65,0xe4,0x61,0x19,0xc3,0xb8,0x0c,     //252
			//0x45,0xa3,0xb4,0xdc,0x23,0x75,0xd4,0xcc,
			
			//0xd2,0xb6,0xe4,0xd1,0x46,0xd3,0xd8,0x0c, //255
			//0x75,0xac,0xb4,0xec,0x23,0x25,0xf4,0xbb,
			
			//0xd3,0xb7,0xe6,0xc1,0x66,0xe3,0xe8,0x2c,   //256
			//0x85,0xbc,0xd4,0xfc,0x63,0x65,0x24,0xb6,

		//0xd4,0xb8,0xe7,0xc3,0x86,0xd3,0x68,0x3c,  //257
		//0xa5,0x3c,0xc4,0x3c,0x83,0x45,0x34,0x96,
		//0xd5,0xb9,0xe8,0xc4,0x87,0xd4,0x78,0x4c, //259
		//0xb5,0x4c,0xc6,0x3d,0x85,0x46,0x36,0x9a,

		//0xd6,0xba,0xe9,0xc5,0x85,0xd2,0x76,0x6c,  //260
		//0xc5,0x6c,0xd6,0x4d,0xa5,0x56,0x66,0x8a,
		//0xd7,0xbb,0xea,0xc6,0x89,0xd6,0x7a,0x4d,  //261
		//0xb8,0x4d,0xd6,0xdd,0xa5,0x66,0x66,0xaa,
		//0xd9,0xbc,0xeb,0xc8,0x8a,0xd8,0x9a,0x5d,  //262
		//0xc8,0x6d,0xe6,0xcd,0x65,0x68,0x96,0xae,	
		//0xa9,0xbb,0xcb,0xda,0xe7,0xf5,0xa0,0x7b, //115
		//0x6d,0x8e,0x8f,0x80,0x51,0x32,0xdc,0x8a,
		//0xda,0xbd,0xec,0xc9,0x8b,0xe8,0xaa,0x6d,  //263
		//0xd8,0x7d,0xf6,0xed,0xa5,0xa8,0xa6,0xfe,
		//0xdb,0xbe,0xed,0xca,0x8c,0xe9,0xab,0x7d,  //265
		//0xe8,0x8d,0xa6,0xad,0xb5,0xb8,0xc6,0xf8,
		//0xeb,0xce,0xfd,0xda,0xac,0xa9,0xdb,0x9d,  //266
		//0xf8,0xad,0xb6,0xcd,0xc5,0xc8,0xe6,0xe8,
		//0xc4,0x65,0xe4,0x51,0x56,0xc3,0xe6,0x0c, //229
		//0x84,0xbf,0xb4,0xac,0x23,0x55,0xe4,0xba,
		//0xef,0xc2,0xf1,0xde,0xa0,0xad,0xdf,0x91,//270
		//0x38,0xed,0xf6,0x0d,0xf5,0xe8,0x26,0x38,
		//0xe2,0xc5,0xf4,0xd1,0xa3,0xa0,0xd2,0x94, //273
		//0x68,0x1d,0x26,0x3d,0x25,0x18,0x56,0x68, 
		//0xe3,0xc6,0xf5,0xd2,0xa4,0xa1,0xd3,0x95,//275
		//0x78,0x2d,0x36,0x4d,0x35,0x28,0x66,0x78,
		//0xe5,0xc8,0xf7,0xd4,0xa7,0xa4,0xd5,0x97,//280
		//0x98,0x4d,0x56,0x6d,0x55,0x48,0x86,0x98,
		//0xe5,0xc8,0xf7,0xd4,0xa6,0xa3,0xd5,0x97,//282
		//0x99,0x4c,0x56,0x6d,0x55,0x48,0x86,0x98,
		//0xe0,0xc2,0x04,0xe6,0xa8,0xaa,0xdb,0x9c,//96001
		//0x9d,0x1d,0x36,0x5d,0x75,0x98,0x86,0x98,
		0xe2,0xc4,0x06,0xe8,0xaa,0xac,0xdd,0xac, //96002
		0xad,0x2d,0x46,0x6d,0x85,0x9a,0x88,0x9a,
    
	};

/*************    函数名：StartBuzzer       ****************************
【功能】：读写卡给出声音提示
【参数】：
【返回】：
【说明】：
**************   设计：南下三五年 2010-11-15  17:23:27*****************/
void StartBuzzer(void)
{
	if(TM.buzzer) return ;
	BUZZERON;
	TM.buzzer=25; 
}

/*************    函数名: OpenMoneyBox  **************************************
【功能】:开钱箱
【参数】:
【返回】:
【说明】:
**************   设计: 南下三五年 2013-08-22 17:57:55 **********************/
void OpenMoneyBox(void)
{
	if(TM.opentime) return ;
	MONEYBOXON;
	TM.opentime=250; 
}
/*************    函数名：FindCardS50             ****************************
【功能】：寻卡
【参数】：
【返回】：
【说明】：
         再次写该函数，更多个考虑从系统的角度出发，而不再是以前写裸机程序的标志
         位的写法，随着以后自己对系统理解的深入，如果时间允许会对系统进行更多的
         优化
**************   设计：南下三五年 2012-06-27  14:30:24***********************/
INT8U Testbuff[40]={0};
INT8U FindCardS50(void)
{
	INT8U status=0;
	
	/*!请求是否有卡*/
  status = Request(RF_CMD_REQUEST_ALL);
	
	/*!无卡的情况下，再次寻卡进行判断*/
	if( FM1702_OK!=status )
	{
		/*!请求是否有卡*/
		status = Request(RF_CMD_REQUEST_ALL);

	/*!无卡数据归零*/
		if( FM1702_OK!=status )
		{
			if(0==FLAG.update)
			{
				FLAG.update=1;

				CARDMSG.id=0;
				CARDMSG.idback=0;
				CARDMSG.coin=0;
				CARDMSG.lottery=0;
				CARDMSG.sta=0;
				CARDMSG.ready=0;
				CARDMSG.type=0;
				CARDMSG.writeready=READCARD;
				FLAG.cardready=0;
				FLAG.waitcard=0;

				FLAG.locksetbit=0;
				FLAG.step=0;
				FLAG.nolock=0;

				FLAG.backset=0;
				CARDMSG.line=0;

				CARDMSG.money=0;
				CARDMSG.step=READCARD;

				StartBuzzer();
			
				CARDMSG.ecoin=0;
				S50.uid[0]=0;
				S50.uid[1]=0;
				S50.uid[2]=0;
				S50.uid[3]=0;
				CARDMSG.id=0;
				
				//!无卡清空会员卡和编号
				;//SendM1CardSNAndNum();

				FLAG.rec=0;
			}

			S50.uidback[0]=0;
			S50.uidback[1]=0;
			S50.uidback[2]=0;
			S50.uidback[3]=0;
			CARDMSG.money=0;
			CARDMSG.step=READCARD;
			
			/*!处理完无卡信息后，快速返回*/
			return 0;
		}       
	}
	/*上下分操作中不寻卡*/
	if(CARDMSG.sta) return 0;
	
	if( FM1702_OK==status )
	{
		/*!判断卡片类型，本系统只识别兼容的S50卡*/
		if(S50.tagtype[0]==2)
				S50.tagtype[1]=mifarepro;     // Mifare Pro 卡
		else if(S50.tagtype[0]==4)
				S50.tagtype[1]=mifare1;       // Mifare One 卡
		else if(S50.tagtype[0]==16)
				S50.tagtype[1]=mifarelight;   // Mifare Light 卡
		else
				S50.tagtype[1]=unknowncard;

		S50.revbuffer[0]=3;
		S50.revbuffer[1]=status;
		S50.revbuffer[2]=S50.tagtype[0];
		S50.revbuffer[3]=S50.tagtype[1]; 

	/*!防冲突处理*/
		status = AntiColl(); 
	
		if(status!=FM1702_OK)
		{//出错
			S50.revbuffer[0]=1;	
			S50.revbuffer[1]=FM1702_ANTICOLLERR;
		}
		else
		{     
			S50.revbuffer[0]=5;
			S50.revbuffer[1]=status;
			S50.revbuffer[2]=S50.uid[0];
			S50.revbuffer[3]=S50.uid[1];
			S50.revbuffer[4]=S50.uid[2];
			S50.revbuffer[5]=S50.uid[3]; 

			/*!获取会员卡序列号，进行DES加解密判断*/
			FLAG.desid[0]=S50.uid[0];
			FLAG.desid[1]=S50.uid[1];
			FLAG.desid[2]=S50.uid[2];
			FLAG.desid[3]=S50.uid[3];

			/*!选择卡*/
			status=Select_Card();
			
			if(status!=FM1702_OK)
			{//选卡出错
					S50.revbuffer[0]=1;	
					S50.revbuffer[1]=FM1702_SELERR; 
			}
			else
			{//选中
				S50.revbuffer[0]=1;
				S50.revbuffer[1]=status;

				/*!加载密钥和认证扇区*/
				S50.revbuffer[1]=RF_CMD_AUTH_LA;
				S50.revbuffer[2]=1; 	           //!扇区号
				S50.revbuffer[3]=gHJM1CardKey[0];  //!密钥 
				S50.revbuffer[4]=gHJM1CardKey[1];
				S50.revbuffer[5]=gHJM1CardKey[2];
				S50.revbuffer[6]=gHJM1CardKey[3];
				S50.revbuffer[7]=gHJM1CardKey[4];
				S50.revbuffer[8]=gHJM1CardKey[5];
				/*!加载密钥*/
				status = Load_keyE2_CPY(S50.revbuffer[2],S50.revbuffer[1]);  
				/*!三重认证*/
				status = Authentication(S50.uid, S50.revbuffer[2], S50.revbuffer[1]);	
	
				if(status != FM1702_OK)
				{
					S50.revbuffer[0]=1;
					S50.revbuffer[1]=status;

					return 0;
				}
				else
				{//认证通过
					S50.revbuffer[0]=1;
					S50.revbuffer[1]=status;

					CARDMSG.ready=1;
					CARDMSG.writeready=1;

					FLAG.cardready=1;
					FLAG.waitcard=1;

					if(!CARDMSG.step)
						StartBuzzer();
					return 1;
				}			
			}            	                                         
		}	
	}
	return 0;
}

/*************    函数名：GetCardMsgS50            ***************************
【功能】：认证通过的卡，获取卡片内数据块信息
【参数】：
【返回】：
【说明】：
**************   设计：南下三五年 2012-06-27  15:40:37***********************/
void GetCardMsgS50(void)
{
	INT8U status=0,i=0;
	INT8U intcoincard[16]={0};
	INT8U *ptr=NULL;
	INT16U crc=0,crc1=0;

#ifdef REQUESTSERVER
	INT32U backid=0;
	CanTxMsg TxMsg;
#endif
	
	/*!不是获取信息，快速返回*/
	if(READCARD!=CARDMSG.step)
		return ;

	/*!不需要更新信息的时候，快速返回*/
	if(CARDMSG.sta)
		return;

	status=MIF_READ(CtrIC.readbuff,4); //读取扇区1的块0 获取ID和公司信息

	if(FM1702_OK !=status )
	{
		S50.revbuffer[0]=1;
		S50.revbuffer[1]=status;
	}
	else 
	{
		//!获取卡号、场地编号、类型
		ptr=(INT8U *)&CARDMSG.id;
		for(i=0;i<4;i++)
			*ptr++=CtrIC.readbuff[i];

		ptr=(INT8U *)&CARDMSG.gameroomsn;

		for(i=0;i<4;i++)
			*ptr++=CtrIC.readbuff[4+i];

		CARDMSG.cardtype=CtrIC.readbuff[8];

		//!判断校验通过
		crc=Crc16Check(CtrIC.readbuff, 9);
		crc1=CtrIC.readbuff[9]+((INT16U)CtrIC.readbuff[10]<<8);
		if(crc==crc1)
		{
			//!如果是注册卡，则回去读卡秘钥和数据加密秘钥
			if(CARDMSG.cardtype==CardType_Register)
			{
				status=MIF_READ(CtrIC.readbuff,5);

				for(i=0;i<8;i++)
					CARDMSG.cardkey3des[i]=CtrIC.readbuff[i];
				
				status=MIF_READ(CtrIC.readbuff,6);

				for(i=0;i<16;i++)
					CARDMSG.carddata3des[i]=CtrIC.readbuff[i];
			}

			RUNLEDON();
			if(0==FLAG.ReaderMode) 
			{
				do
				{
					;//SendM1CardSNAndNum();
				}while(xSemaphoreTake( xAskServerSemaphore, ( portTickType ) SERVERQUESTTIME)!= pdTRUE);
			}
			else
			{
				//!获取玩家余额
				status=MIF_READ(CtrIC.readbuff,5); //!正常

				if(status != FM1702_OK)
				{
					S50.revbuffer[0]=1;
					S50.revbuffer[1]=status;
					CtrIC.err=ERR_READ; //读卡错误
				}
				else
				{
					CARDMSG.coin=(u32)(CtrIC.readbuff[0]+(((u32)CtrIC.readbuff[1])<<8)+(((u32)CtrIC.readbuff[2])<<16)+(((u32)CtrIC.readbuff[3])<<24));
					FLAG.desinbuf[0]=CtrIC.readbuff[0];
					FLAG.desinbuf[1]=CtrIC.readbuff[1];
					FLAG.desinbuf[2]=CtrIC.readbuff[2];
					FLAG.desinbuf[3]=CtrIC.readbuff[3];

					FLAG.desinbuf[4]=FLAG.desid[0];
					FLAG.desinbuf[5]=FLAG.desid[1];
					FLAG.desinbuf[6]=FLAG.desid[2];
					FLAG.desinbuf[7]=FLAG.desid[3];

					//DesEncrypt( FLAG.desinbuf, Deskey ,FLAG.descheckbuf);
					for(i=0;i<16;i++)
					{
						Deskey[i]=KEY4[i];
					}
					TripDes(FLAG.desinbuf,KEYDES,&KEYDES[8],1);//注意是3DES

					for(i=0;i<8;i++)
					{
						if(FLAG.desinbuf[i]!=CtrIC.readbuff[4+i])
							break;
					}

					if(i<8)
					{
						FLAG.coinerr=1;
						CARDMSG.coin=0;
					}
					else
						FLAG.coinerr=0;

					do
					{
						;//SendSetPlayerMoney();
					}while(xSemaphoreTake( xAskServerSemaphore, ( portTickType ) SERVERQUESTTIME)!= pdTRUE);

				}

				//!获取玩家余票
				status=MIF_READ(CtrIC.readbuff,6); //!正常

				if(status != FM1702_OK)
				{
					S50.revbuffer[0]=1;
					S50.revbuffer[1]=status;
					CtrIC.err=ERR_READ; //读卡错误
				}
				else
				{
					CARDMSG.lottery=(u32)(CtrIC.readbuff[0]+(((u32)CtrIC.readbuff[1])<<8)+(((u32)CtrIC.readbuff[2])<<16)+(((u32)CtrIC.readbuff[3])<<24));
					FLAG.desinbuf[0]=CtrIC.readbuff[0];
					FLAG.desinbuf[1]=CtrIC.readbuff[1];
					FLAG.desinbuf[2]=CtrIC.readbuff[2];
					FLAG.desinbuf[3]=CtrIC.readbuff[3];

					FLAG.desinbuf[4]=FLAG.desid[0];
					FLAG.desinbuf[5]=FLAG.desid[1];
					FLAG.desinbuf[6]=FLAG.desid[2];
					FLAG.desinbuf[7]=FLAG.desid[3];

					//DesEncrypt( FLAG.desinbuf, Deskey ,FLAG.descheckbuf);
					for(i=0;i<16;i++)
					{
						Deskey[i]=KEY4[i];
					}
					TripDes(FLAG.desinbuf,KEYDES,&KEYDES[8],1);//注意是3DES

					for(i=0;i<8;i++)
					{
						if(FLAG.desinbuf[i]!=CtrIC.readbuff[4+i])
							break;
					}

					if(i<8)
					{
						FLAG.coinerr=1;
						CARDMSG.lottery=0;
					}
					else
						FLAG.coinerr=0;

					do
					{
						;//SendSetPlayerLottery();
					}while(xSemaphoreTake( xAskServerSemaphore, ( portTickType ) SERVERQUESTTIME)!= pdTRUE);

				}
			}
			
			xSemaphoreGive( xLEDSendSemaphore );
		}
		else
		{
			StartBuzzer();
		}
		
		FLAG.update=0;
		CARDMSG.sta=1;
	}
}
/*************    函数名：SetCardSysS50           ***************************
【功能】：设置解锁卡参数
【参数】：
【返回】：
【说明】：
**************   设计：南下三五年 2012-06-30  13:36:30***********************/
void SetCardSysS50(void)
{
	#if 0
	INT32U i=0,status=0;
	INT32U temp=0;

	/*!不是设置模式，快速返回*/
	if(CARDMSG.step<2)
		return ;
	
	/*!设置密码*/
	if(CARDMSG.step==STEPPASS&&CARDMSG.writeready)//
	{
		CARDMSG.step=READCARD;
		CARDMSG.writeready=0;

		CARDMSG.oldpass=CARDMSG.checkpass;
		CARDMSG.usepass=ST.password;

		for(i=0;i<4;i++)
        {
        	CARDMSG.writebuff[i]=CARDMSG.idback;
            CARDMSG.writebuff[4+i]=CARDMSG.oldpass;
            CARDMSG.writebuff[8+i]=CARDMSG.usepass;
            CARDMSG.idback>>=8;
            CARDMSG.oldpass>>=8;
            CARDMSG.usepass>>=8;
        }  
            
        status=MIF_Write(CARDMSG.writebuff,4);  //写密码，扇区1，块0
                       
        if(status!=FM1702_OK)
        	CtrIC.err=6; //写卡错误
        else
        	CtrIC.err=11;//写卡成功
	}

	/*!设置币值*/
	if(CARDMSG.step==STEPMONEY&&CARDMSG.writeready)
	{
		CARDMSG.step=READCARD;
		CARDMSG.writeready=0;

		temp=ST.moneybi;
		
		status=MIF_READ(CARDMSG.writebuff,5); //获取解锁密码和分数限制

		if(status!=FM1702_OK)
		{
			
		}
		else
		{
			for(i=0;i<2;i++)
	        {
				CARDMSG.writebuff[14+i]=temp;
				temp>>=8;
	        }
						
			status=MIF_Write(CARDMSG.writebuff,5);  //写密码，扇区1，块0  

			//增加错误处理              
		    if(status!=FM1702_OK)
		        CtrIC.err=6; //写卡错误
		     else
		        CtrIC.err=11;//写卡成功

			CARDMSG.sta=0;
		}
	}
	
	/*!设置最大上分限制*/
	if(CARDMSG.step==STEPLIMIT&&CARDMSG.writeready)
	{
		CARDMSG.step=READCARD;
		CARDMSG.writeready=0;

		status=MIF_READ(CARDMSG.writebuff,5); //获取解锁密码和分数限制

		if(status!=FM1702_OK)
		{
			
		}
		else
		{
			CtrIC.limitup=ST.limitup;
			temp=ST.limitup;
			for(i=0;i<4;i++)
            {
                CARDMSG.writebuff[8+i]=temp;
                temp>>=8;
            }
			
			status=MIF_Write(CARDMSG.writebuff,5);  //写密码，扇区1，块0            
            if(status!=FM1702_OK)
                CtrIC.err=6; //写卡错误
            else
                CtrIC.err=11;//写卡成功
		}
	}
	/*!设置押金*/
	if(CARDMSG.step==STEPYAJIN&&CARDMSG.writeready)
	{
		CARDMSG.step=0;
		CARDMSG.writeready=0;

		status=MIF_READ(CARDMSG.writebuff,5); //获取解锁密码和分数限制

		if(status!=FM1702_OK)
		{
			
		}
		else
		{
			CARDMSG.writebuff[15]=ST.yajin;
						
			status=MIF_Write(CARDMSG.writebuff,5);  //写密码，扇区1，块0            
	        if(status!=FM1702_OK)
	            CtrIC.err=6; //写卡错误
	        else
	        {
	        	CtrIC.err=11;//写卡成功
	            CtrIC.step=0;
	        }
		}
	}
	#endif
}

/*************    函数名：AddOrDecCardCoinS50         ************************
【功能】：更新会员信息
【参数】：
【返回】：
【说明】：
**************   设计：南下三五年 2012-06-30  13:37:53***********************/
void AddOrDecCardCoinS50(void)
{
	//!写卡同步玩家币值
	//!----------------------------------------------------
	/*!不需要更新会员信息，快速返回*/
    INT8U i=0,status=0;

	if(WRITCARD!=CARDMSG.step)
		return ;

	if(FLAG.WriteCardStop)
	{
		CARDMSG.step=READCARD;
		return ;
	}

	CARDMSG.money=CARDMSG.coin;
	for(i=0;i<4;i++)
	{
		CARDMSG.writebuff[i]=CARDMSG.money;
		CARDMSG.money>>=8;
	}

	CARDMSG.money=0;

	/*!DES加密*/
	FLAG.desinbuf[0]=CARDMSG.writebuff[0];
	FLAG.desinbuf[1]=CARDMSG.writebuff[1];
	FLAG.desinbuf[2]=CARDMSG.writebuff[2];
	FLAG.desinbuf[3]=CARDMSG.writebuff[3];

	FLAG.desinbuf[4]=FLAG.desid[0];
	FLAG.desinbuf[5]=FLAG.desid[1];
	FLAG.desinbuf[6]=FLAG.desid[2];
	FLAG.desinbuf[7]=FLAG.desid[3];

	for(i=0;i<16;i++)
	{
		Deskey[i]=KEY4[i];
	}
	TripDes(FLAG.desinbuf,Deskey,&Deskey[8],1);//注意是3DES

	for(i=0;i<8;i++)
		CARDMSG.writebuff[4+i]=FLAG.desinbuf[i];
	
	status=MIF_Write(CARDMSG.writebuff,5); //数据存储在扇区1的块1
	
	//!----------------------------------------------------
}
/*************    函数名：ResetDate         ****************************
【功能】：
【参数】：
【返回】：
【说明】：
**************   设计：南下三五年 2010-11-16  16:14:16*****************/
INT8U const compile_time[20]=__DATE__ __TIME__;              
   
void ResetDate(void)  
{

}
/*************    函数名：InitCardPassword         *********************
【功能】：系统第一次上电，初始化卡片参数
【参数】：
【返回】：
【说明】：
**************   设计：南下三五年 2010-11-15  01:48:48*****************/
void InitCardPassword(void)
{

}

/*************    函数名：vFM1702MangerTask     ************************
【功能】：
【参数】：
【返回】：
【说明】：
			由于在这个任务中，错误的禁止了任务的切换，导致使用邮箱后，系统
			错误，后来，调整为SPI操作时，禁止任务切换，系统正常，
**************   设计：木瓜 2010-11-02  22:54:52***********************/
void vFM1702MangerTask( void *pvParameters )
{
	/*!使用绝对时间，保证系统0.5S运行一次*/
	portTickType xLastWakeTime;
	
	#ifdef PRINTFMSG
		printf("FM1702 Task ok \r\n");
	#endif
	/*!初始化FM1702*/
	Init_FM1702(0);

	/*!使用当前时间 初始化xLastWakeTime 变量*/
    xLastWakeTime = xTaskGetTickCount();

	#ifdef PRINTFMSG
		printf("FM1702 IS OK \r\n");
	#endif

	for(;;)
	{
		if(FindCardS50())
		{
			#ifdef PRINTFMSG
				printf("find card \r\n");
			#endif
			GetCardMsgS50();
			AddOrDecCardCoinS50();
		}
		/*!产生周期性的调度，固定的0.5S执行一次*/
		/*!产生周期性的调度，固定的1S执行一次*/
		SPIWrite(TxControl,0x50);		   //address 11H    /* 发送控制寄存器 */
		xLastWakeTime = xTaskGetTickCount();
		vTaskDelayUntil( &xLastWakeTime, configTICK_RATE_HZ/3 );	
		SPIWrite(TxControl,0x5b);		   //address 11H    /* 发送控制寄存器 */ 

		#if 1
		if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_4)==0)
		{
			FLAG.ReaderMode=1;
		}
		else
			FLAG.ReaderMode=0;
		#endif
	}
}



